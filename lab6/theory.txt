pthreads


PThreads = POSIX Threads
<pthreads.h> - определяет интерфейс потоков.
Поддержка - _POSIX_THREADS


Для чего формируется поток - для решения нескольких задач в рамках единственного процеса. 

Все потоки внутри процеса имеют доступ к одним и тем же компонентам процесса, таким как файловые дескрипторы или переменные.

Потоки, в отличие от процессов, автоматически получают доступ к одному и тому же адресному пространству и файловым дескрипторам.

Поток содержит набор информации, необходимой для представления кон-
текста исполнения внутри процесса: 
- идентификатор потока - идентифицирует поток внутри процесса
- набор значений в регистрах процессора
- стек
- переменная errno
- Все компоненты процесса, включая исполняемый код программы, глобаль-
ные переменные и динамическую память, стеки и файловые дескрипторы,
могут совместно использоваться различными потоками этого процесса.

Ідентифікація потоку - pthread_t. Это не просто целое число. В разных ОС разное представление. Поэтому сравниваем не сравнением, а с помощью 
int pth read_equal(pth read_t tidl , pthread_t tid2) 
	!0 - если равны
	0 - если равны

pthread pthread_self(void) - получение своего собственного идентификатора.

Создание потока
Сначала один процес == один поток.
При наличии pthreads программа также запускается как процесс, состоящий из одного потока управления.
Создание дополнительных потоков - с помощью функции pthread_create

int pthread_create(pthread_t * thread, const pthread_attr_t * attr, void *(*start_routine)(void), void *arg);
	0 - успех
	код ошибки - неудача. errno не изменяется
thread - область памяти для идентификатора созданного потока
attr - атрибуты потока. NULL по умолчанию
start_routine - с чего начинает работать созданный поток.

Новый поток имеет доступ к адресному пространству процесса и наследует от вызывающего потока среду окружения арифметического сопроцессора и маску сигналов, однако набор сигналов, ожидающих обработки, для нового потока очищается.

1 интересный момент
Если просто использовать pthread_create - необходимо приостановить основной поток. Ес-
ли этого не сделать, то основной поток может завершиться и тем самым за-
вершить весь процесс еще до того, как новый поток получит возможность
начать работу. Такое поведение потоков во многом зависит от реализации
потоков в операционной системе и алгоритма планирования.
2 интересный момент
новый поток получает свой идентификатор с помощью функции pthread_self, а не берет его из гло-
бальной переменной или из аргумента запускающей функции.

Оба созданных потока имеют один и тот же идентификатор процесса, но разные идентификаторы потоков.

Первый выводит основной поток

Завершение потока:
exit, _exit или _Exit - завершается весь процес
Завершить работу единственного потока, то есть без завершения всего про-
цесса, можно тремя способами.
1. Поток может просто вернуть управление из запускающей процедуры.
Возвращаемое значение этой процедуры - код завершения потока.
2. Поток может быть принудительно завершен другим потоком того же самого
процесса.
3. Поток может вызвать функцию pthread_exit.
void pthread_exit(void *rval_ptr)


pthread_join - ждёт закрытия потока
	0 - success
	код ошибки - ошибка

что делает джоин - ждёт

решение проблемы согласования доступа - механизмы синхронизации потоков, которые позволяют предотвратить доступ разных потоков к разделяемым ресурсам, находящимся в несогласованном состоянии.

pthread_create - обычный call функции, но с особенностью - командный поинтер!!
паралельное выполнение с точки зрения scheduler-a - командный поинтер!!
при pthread_create scheduler что делает = командный поинтер!!


